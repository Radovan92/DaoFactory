"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubscriptionController = void 0;
const await_semaphore_1 = require("@broxus/await-semaphore");
const subscription_1 = require("./subscription");
const DEFAULT_POLLING_INTERVAL = 10000; // 10s
class SubscriptionController {
    constructor(connectionController, notify) {
        this._subscriptions = new Map();
        this._subscriptionsMutex = new await_semaphore_1.Mutex();
        this._sendMessageRequests = new Map();
        this._subscriptionStates = new Map();
        this._connectionController = connectionController;
        this._notify = notify;
    }
    async sendMessageLocally(address, signedMessage) {
        await this.subscribeToContract(address, { state: true });
        const subscription = this._subscriptions.get(address);
        if (subscription == null) {
            throw new Error('Failed to subscribe to contract');
        }
        return await subscription.use((contract) => contract.sendMessageLocally(signedMessage));
    }
    sendMessage(address, signedMessage) {
        let messageRequests = this._sendMessageRequests.get(address);
        if (messageRequests == null) {
            messageRequests = new Map();
            this._sendMessageRequests.set(address, messageRequests);
        }
        return new Promise((resolve, reject) => {
            const id = signedMessage.hash;
            messageRequests.set(id, { resolve, reject });
            this.subscribeToContract(address, { state: true })
                .then(async () => {
                const subscription = this._subscriptions.get(address);
                if (subscription == null) {
                    throw new Error('Failed to subscribe to contract');
                }
                await subscription.prepareReliablePolling();
                await subscription
                    .use(async (contract) => {
                    await contract.sendMessage(signedMessage);
                    subscription.skipRefreshTimer();
                });
            })
                .catch((e) => this._rejectMessageRequest(address, id, e));
        });
    }
    async subscribeToContract(address, params) {
        return this._subscriptionsMutex.use(async () => {
            let shouldUnsubscribe = true;
            const currentParams = this._subscriptionStates.get(address) || makeDefaultSubscriptionState();
            Object.keys(currentParams).map((param) => {
                if (param !== 'state' && param !== 'transactions') {
                    throw new Error(`Unknown subscription topic: ${param}`);
                }
                const value = params[param];
                if (typeof value === 'boolean') {
                    currentParams[param] = value;
                }
                else if (value == null) {
                    return;
                }
                else {
                    throw new Error(`Unknown subscription topic value ${param}: ${value}`);
                }
                shouldUnsubscribe && (shouldUnsubscribe = !currentParams[param]);
            });
            if (shouldUnsubscribe) {
                this._subscriptionStates.delete(address);
                await this._tryUnsubscribe(address);
                return { ...currentParams };
            }
            let existingSubscription = this._subscriptions.get(address);
            const isNewSubscription = existingSubscription == null;
            if (existingSubscription == null) {
                existingSubscription = await this._createSubscription(address);
            }
            this._subscriptionStates.set(address, currentParams);
            if (isNewSubscription) {
                await existingSubscription.start();
            }
            return { ...currentParams };
        });
    }
    async unsubscribeFromContract(address) {
        await this.subscribeToContract(address, {
            state: false,
            transactions: false,
        });
    }
    async unsubscribeFromAllContracts() {
        for (const address of this._subscriptions.keys()) {
            await this.unsubscribeFromContract(address);
        }
    }
    get subscriptionStates() {
        const result = {};
        for (const [key, value] of this._subscriptionStates.entries()) {
            result[key] = value;
        }
        return result;
    }
    async _createSubscription(address) {
        class ContractHandler {
            constructor(address, controller) {
                this._enabled = false;
                this._address = address;
                this._controller = controller;
            }
            enabledNotifications() {
                this._enabled = true;
            }
            onMessageExpired(pendingTransaction) {
                if (this._enabled) {
                    this._controller
                        ._resolveMessageRequest(this._address, pendingTransaction.messageHash, undefined)
                        .catch(console.error);
                }
            }
            onMessageSent(pendingTransaction, transaction) {
                if (this._enabled) {
                    this._controller
                        ._resolveMessageRequest(this._address, pendingTransaction.messageHash, transaction)
                        .catch(console.error);
                }
            }
            onStateChanged(newState) {
                if (this._enabled) {
                    this._controller._notifyStateChanged(this._address, newState);
                }
            }
            onTransactionsFound(transactions, info) {
                if (this._enabled) {
                    this._controller._notifyTransactionsFound(this._address, transactions, info);
                }
            }
        }
        const handler = new ContractHandler(address, this);
        const subscription = await subscription_1.ContractSubscription.subscribe(this._connectionController, address, handler);
        subscription.setPollingInterval(DEFAULT_POLLING_INTERVAL);
        handler.enabledNotifications();
        this._subscriptions.set(address, subscription);
        return subscription;
    }
    async _tryUnsubscribe(address) {
        const subscriptionState = this._subscriptionStates.get(address);
        const sendMessageRequests = this._sendMessageRequests.get(address);
        if (subscriptionState == null && ((sendMessageRequests === null || sendMessageRequests === void 0 ? void 0 : sendMessageRequests.size) || 0) == 0) {
            const subscription = this._subscriptions.get(address);
            this._subscriptions.delete(address);
            await (subscription === null || subscription === void 0 ? void 0 : subscription.stop());
        }
    }
    async _rejectMessageRequest(address, id, error) {
        this._deleteMessageRequestAndGetCallback(address, id).reject(error);
        await this._subscriptionsMutex.use(async () => this._tryUnsubscribe(address));
    }
    async _resolveMessageRequest(address, id, transaction) {
        this._deleteMessageRequestAndGetCallback(address, id).resolve(transaction);
        await this._subscriptionsMutex.use(async () => this._tryUnsubscribe(address));
    }
    _notifyStateChanged(address, state) {
        const subscriptionState = this._subscriptionStates.get(address);
        if (subscriptionState === null || subscriptionState === void 0 ? void 0 : subscriptionState.state) {
            this._notify('contractStateChanged', {
                address,
                state,
            });
        }
    }
    _notifyTransactionsFound(address, transactions, info) {
        const subscriptionState = this._subscriptionStates.get(address);
        if (subscriptionState === null || subscriptionState === void 0 ? void 0 : subscriptionState.transactions) {
            this._notify('transactionsFound', {
                address,
                transactions,
                info,
            });
        }
    }
    _deleteMessageRequestAndGetCallback(address, id) {
        var _a;
        const callbacks = (_a = this._sendMessageRequests.get(address)) === null || _a === void 0 ? void 0 : _a.get(id);
        if (!callbacks) {
            throw new Error(`SendMessage request with id '${id}' not found`);
        }
        this._deleteMessageRequest(address, id);
        return callbacks;
    }
    _deleteMessageRequest(address, id) {
        const accountMessageRequests = this._sendMessageRequests.get(address);
        if (!accountMessageRequests) {
            return;
        }
        accountMessageRequests.delete(id);
        if (accountMessageRequests.size == 0) {
            this._sendMessageRequests.delete(address);
        }
    }
}
exports.SubscriptionController = SubscriptionController;
const makeDefaultSubscriptionState = () => ({
    state: false,
    transactions: false,
});
