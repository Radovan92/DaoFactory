"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUniqueId = exports.mergeTransactions = exports.LT_COLLATOR = exports.DelayedTransactions = exports.MessageExpiredException = exports.AddressLiteral = exports.Address = void 0;
/**
 * @category Utils
 */
class Address {
    constructor(address) {
        this.equals = (other) => this._equals(other);
        this._address = address;
    }
    toString() {
        return this._address;
    }
    toJSON() {
        return this._address;
    }
    _equals(other) {
        if (other instanceof Address) {
            return this._address === other._address;
        }
        else {
            return this._address === other;
        }
    }
}
exports.Address = Address;
/**
 * @category Utils
 */
class AddressLiteral extends Address {
    constructor(address) {
        super(address);
    }
}
exports.AddressLiteral = AddressLiteral;
/**
 * @category Utils
 */
class MessageExpiredException extends Error {
    constructor(address, hash) {
        super('Message expired');
        this.address = address;
        this.hash = hash;
    }
}
exports.MessageExpiredException = MessageExpiredException;
class DelayedTransactions {
    constructor() {
        this.transactions = new Map();
    }
    async waitTransaction(address, hash) {
        var _a;
        let transaction = (_a = this.transactions.get(hash)) === null || _a === void 0 ? void 0 : _a.promise;
        if (transaction == null) {
            let resolve;
            let reject;
            transaction = new Promise((promiseResolve, promiseReject) => {
                resolve = (tx) => promiseResolve(tx);
                reject = () => promiseReject();
            });
            this.transactions.set(hash, {
                promise: transaction,
                resolve: resolve,
                reject: reject,
            });
        }
        const tx = await transaction;
        if (tx == null) {
            throw new MessageExpiredException(address, hash);
        }
        return tx;
    }
    fillTransaction(hash, transaction) {
        const pendingTransaction = this.transactions.get(hash);
        if (pendingTransaction != null) {
            pendingTransaction.resolve(transaction);
        }
        else {
            this.transactions.set(hash, {
                promise: Promise.resolve(transaction),
                resolve: () => {
                },
                reject: () => {
                },
            });
        }
    }
}
exports.DelayedTransactions = DelayedTransactions;
/**
 * @category Utils
 */
exports.LT_COLLATOR = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });
/**
 * Modifies knownTransactions array, merging it with new transactions.
 * All arrays are assumed to be sorted by descending logical time.
 *
 * > Note! This method does not remove duplicates.
 *
 * @param knownTransactions
 * @param newTransactions
 * @param info
 *
 * @category Utils
 */
function mergeTransactions(knownTransactions, newTransactions, info) {
    if (info.batchType === 'old') {
        knownTransactions.push(...newTransactions);
        return knownTransactions;
    }
    if (knownTransactions.length === 0) {
        knownTransactions.push(...newTransactions);
        return knownTransactions;
    }
    // Example:
    // known lts: [N, N-1, N-2, N-3, (!) N-10,...]
    // new lts: [N-4, N-5]
    // batch info: { minLt: N-5, maxLt: N-4, batchType: 'new' }
    // 1. Skip indices until known transaction lt is greater than the biggest in the batch
    let i = 0;
    while (i < knownTransactions.length &&
        exports.LT_COLLATOR.compare(knownTransactions[i].id.lt, info.maxLt) >= 0) {
        ++i;
    }
    // 2. Insert new transactions
    knownTransactions.splice(i, 0, ...newTransactions);
    return knownTransactions;
}
exports.mergeTransactions = mergeTransactions;
const MAX = 4294967295;
let idCounter = Math.floor(Math.random() * MAX);
function getUniqueId() {
    idCounter = (idCounter + 1) % MAX;
    return idCounter;
}
exports.getUniqueId = getUniqueId;
