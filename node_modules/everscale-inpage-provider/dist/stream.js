"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Subscriber = void 0;
const utils_1 = require("./utils");
/**
 * @category Stream
 */
class Subscriber {
    constructor(provider) {
        this.provider = provider;
        this.subscriptions = new Map();
        this.scanners = new Map();
        this.unsubscribe = async () => this._unsubscribe();
    }
    /**
     * Returns a stream of new transactions
     */
    transactions(address) {
        return this._addSubscription('transactionsFound', address, false);
    }
    /**
     * Returns a finite stream of child transactions
     * @param transaction - root transaction
     */
    trace(transaction) {
        const id = (0, utils_1.getUniqueId)();
        return new StreamImpl((onData, onEnd) => {
            const scanner = new TraceTransactionsScanner(this, {
                origin: transaction,
                onData,
                onEnd: (eof) => {
                    this.scanners.delete(id);
                    onEnd(eof);
                },
            });
            this.scanners.set(id, scanner);
            scanner.start();
            // Subscription is not required
            return Promise.resolve();
        }, async () => {
            const scanner = this.scanners.get(id);
            if (scanner != null) {
                this.scanners.delete(id);
                await scanner.stop();
            }
        }, identity, true);
    }
    /**
     * Returns a stream of old transactions
     */
    oldTransactions(address, filter) {
        const id = (0, utils_1.getUniqueId)();
        return new StreamImpl((onData, onEnd) => {
            const scanner = new UnorderedTransactionsScanner(this.provider, {
                address,
                onData,
                onEnd: (eof) => {
                    this.scanners.delete(id);
                    onEnd(eof);
                },
                ...filter,
            });
            this.scanners.set(id, scanner);
            scanner.start();
            // Subscription is not required
            return Promise.resolve();
        }, async () => {
            const scanner = this.scanners.get(id);
            if (scanner != null) {
                this.scanners.delete(id);
                await scanner.stop();
            }
        }, identity, true);
    }
    states(address) {
        return this._addSubscription('contractStateChanged', address, false);
    }
    async _unsubscribe() {
        const tasks = [];
        for (const item of this.subscriptions.values()) {
            for (const [event, eventData] of Object.entries(item)) {
                delete item[event];
                if (eventData != null) {
                    tasks.push(eventData.subscription
                        .then(item => item.unsubscribe())
                        .catch(() => {
                    }));
                }
            }
        }
        this.subscriptions.clear();
        for (const scanner of this.scanners.values()) {
            tasks.push(scanner.stop());
        }
        this.scanners.clear();
        await Promise.all(tasks);
    }
    _addSubscription(event, address, isFinite) {
        const rawAddress = address.toString();
        const stopProducer = (id) => {
            const subscriptions = this.subscriptions.get(rawAddress);
            if (subscriptions == null) {
                // No subscriptions for the address
                return;
            }
            const eventData = subscriptions[event];
            if (eventData != null) {
                const handler = eventData.handlers.get(id);
                if (handler != null) {
                    // Remove event handler with the id
                    eventData.handlers.delete(id);
                    const { queue, onEnd, state } = handler;
                    if (!state.finished) {
                        state.finished = true;
                        queue.clear();
                        queue.enqueue(async () => onEnd(state.eof));
                    }
                }
                // Remove event data subscription if there are none of them
                if (eventData.handlers.size === 0) {
                    const subscription = eventData.subscription;
                    delete subscriptions[event];
                    subscription
                        .then((subscription) => subscription.unsubscribe())
                        .catch(console.debug);
                }
            }
            // Remove address subscriptions object if it is empty
            if (subscriptions.contractStateChanged == null && subscriptions.transactionsFound == null) {
                this.subscriptions.delete(rawAddress);
            }
        };
        const id = (0, utils_1.getUniqueId)();
        return new StreamImpl((onData, onEnd) => {
            const subscriptions = this.subscriptions.get(rawAddress);
            let eventData = subscriptions === null || subscriptions === void 0 ? void 0 : subscriptions[event];
            const state = { eof: false, finished: false };
            // Create handler object
            const handler = {
                onData,
                onEnd,
                queue: new PromiseQueue(),
                state,
            };
            if (eventData != null) {
                // Add handler if there is already a handler group
                eventData.handlers.set(id, handler);
                return Promise.resolve();
            }
            // Create handlers group
            const handlers = new Map();
            handlers.set(id, handler);
            // Create subscription
            const subscription = this.provider.subscribe(event, { address })
                .then((subscription) => {
                subscription.on('data', (data) => {
                    for (const { onData, queue, state } of handlers.values()) {
                        // Skip closed streams
                        if (state.eof || state.finished) {
                            continue;
                        }
                        queue.enqueue(async () => {
                            if (!(await onData(data))) {
                                state.eof = true;
                                stopProducer(id);
                            }
                        });
                    }
                });
                subscription.on('unsubscribed', () => {
                    for (const id of handlers.keys()) {
                        stopProducer(id);
                    }
                });
                return subscription;
            }).catch((e) => {
                console.error(e);
                for (const id of handlers.keys()) {
                    stopProducer(id);
                }
                throw e;
            });
            // Add event data to subscriptions
            eventData = { subscription, handlers };
            if (subscriptions == null) {
                this.subscriptions.set(rawAddress, { [event]: eventData });
            }
            else {
                subscriptions[event] = eventData;
            }
            // Wait until subscribed
            return subscription.then(() => {
            });
        }, () => stopProducer(id), identity, isFinite);
    }
}
exports.Subscriber = Subscriber;
async function identity(item, handler) {
    return handler(item);
}
class StreamImpl {
    constructor(makeProducer, stopProducer, extractor, isFinite) {
        this.makeProducer = makeProducer;
        this.stopProducer = stopProducer;
        this.extractor = extractor;
        this.isFinite = isFinite;
        /**
         * Folds every element into an accumulator by applying an operation, returning the final result
         */
        this.fold = this.onlyFinite((init, f, ctx) => {
            let state = init;
            return new Promise((resolve, reject) => {
                const subscribed = this.makeProducer(
                // onData
                (data) => this.extractor(data, async (item) => {
                    state = await f(state, item);
                    return true;
                }), 
                // onEnd
                (eof) => {
                    if (eof) {
                        resolve(state);
                    }
                    else {
                        reject(new Error('Subscription closed'));
                    }
                });
                if (ctx != null) {
                    ctx.subscribed = subscribed;
                }
            });
        });
        /**
         * Waits until the end of the stream
         */
        this.finished = this.onlyFinite((ctx) => {
            return new Promise((resolve, reject) => {
                const subscribed = this.makeProducer(
                // onData
                (data) => this.extractor(data, (_item) => true), 
                // onEnd
                (eof) => {
                    if (eof) {
                        resolve(undefined);
                    }
                    else {
                        reject(new Error('Subscription closed'));
                    }
                });
                if (ctx != null) {
                    ctx.subscribed = subscribed;
                }
            });
        });
    }
    async delayed(f) {
        const { subscribed, result } = f({
            first: (() => {
                const ctx = {};
                const result = this.first(ctx);
                return { subscribed: ctx.subscribed, result };
            }),
            on: (handler) => {
                const ctx = {};
                this.on(handler, ctx);
                return { subscribed: ctx.subscribed, result: undefined };
            },
            fold: this.fold != null ? (init, f) => {
                const ctx = {};
                const result = this.fold(init, f, ctx);
                return { subscribed: ctx.subscribed, result };
            } : undefined,
            finished: this.finished != null ? () => {
                const ctx = {};
                const result = this.finished(ctx);
                return { subscribed: ctx.subscribed, result };
            } : undefined,
        });
        await subscribed;
        return () => result;
    }
    first(ctx) {
        const state = { found: false };
        return new Promise((resolve, reject) => {
            const subscribed = this.makeProducer(
            // onData
            (data) => this.extractor(data, (item) => {
                Object.assign(state, { found: true, result: item });
                return false;
            }), 
            // onEnd
            (eof) => {
                if (eof) {
                    if (this.isFinite) {
                        resolve((state.found ? state.result : undefined));
                    }
                    else if (state.found) {
                        resolve(state.result);
                    }
                    else {
                        reject(new Error('Unexpected end of stream'));
                    }
                }
                else {
                    reject(new Error('Subscription closed'));
                }
            });
            if (ctx != null) {
                ctx.subscribed = subscribed;
            }
        });
    }
    on(handler, ctx) {
        const subscribed = this.makeProducer((event) => this.extractor(event, async (item) => {
            await handler(item);
            return true;
        }), (_eof) => {
        });
        if (ctx != null) {
            ctx.subscribed = subscribed;
        }
    }
    merge(other) {
        return new StreamImpl((onData, onEnd) => {
            const state = {
                stopped: false,
                counter: 0,
            };
            const checkEnd = (eof) => {
                if (state.stopped) {
                    return;
                }
                if (++state.counter == 2 || !eof) {
                    state.stopped = true;
                    onEnd(eof);
                }
            };
            return Promise.all([
                this.makeProducer(onData, checkEnd),
                other.makeProducer(onData, checkEnd),
            ]).then(() => {
            });
        }, () => {
            this.stopProducer();
            other.stopProducer();
        }, this.extractor, (this.isFinite && other.isFinite));
    }
    enumerate() {
        const state = {
            index: 0,
        };
        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {
            return handler({
                index: state.index++,
                item,
            });
        }), this.isFinite);
    }
    tap(f) {
        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {
            await f(item);
            return handler(item);
        }), this.isFinite);
    }
    filter(f) {
        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {
            if (await f(item)) {
                return handler(item);
            }
            else {
                return true;
            }
        }), this.isFinite);
    }
    filterMap(f) {
        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {
            const newItem = await f(item);
            if (newItem !== undefined) {
                return handler(newItem);
            }
            else {
                return true;
            }
        }), this.isFinite);
    }
    map(f) {
        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {
            const newItem = await f(item);
            return handler(newItem);
        }), this.isFinite);
    }
    flatMap(f) {
        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {
            const items = await f(item);
            for (const newItem of items) {
                if (!(await handler(newItem))) {
                    return false;
                }
            }
            return true;
        }), this.isFinite);
    }
    skip(n) {
        const state = {
            index: 0,
        };
        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, (item) => {
            if (state.index >= n) {
                return handler(item);
            }
            else {
                ++state.index;
                return true;
            }
        }), this.isFinite);
    }
    skipWhile(f) {
        const state = {
            shouldSkip: true,
        };
        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {
            if (!state.shouldSkip || !(await f(item))) {
                state.shouldSkip = false;
                return handler(item);
            }
            else {
                return true;
            }
        }), this.isFinite);
    }
    take(n) {
        const state = {
            index: 0,
        };
        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, (item) => {
            if (state.index < n) {
                ++state.index;
                return handler(item);
            }
            else {
                return false;
            }
        }), true);
    }
    takeWhile(f) {
        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {
            if (await f(item)) {
                return handler(item);
            }
            else {
                return false;
            }
        }), true);
    }
    takeWhileMap(f) {
        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {
            const newItem = await f(item);
            if (newItem !== undefined) {
                return handler(newItem);
            }
            else {
                return false;
            }
        }), true);
    }
    onlyFinite(f) {
        if (this.isFinite) {
            return f;
        }
        else {
            return undefined;
        }
    }
}
class UnorderedTransactionsScanner {
    constructor(provider, params) {
        this.provider = provider;
        this.params = params;
        this.queue = new PromiseQueue();
        this.isRunning = false;
    }
    start() {
        if (this.isRunning || this.promise != null) {
            return;
        }
        this.isRunning = true;
        this.promise = (async () => {
            const params = this.params;
            const state = {
                complete: false,
            };
            while (this.isRunning && !state.complete) {
                try {
                    const { transactions, continuation } = await this.provider.getTransactions({
                        address: this.params.address,
                        continuation: this.continuation,
                    });
                    state.complete = !state.complete && transactions.length == null;
                    if (!this.isRunning || state.complete) {
                        break;
                    }
                    const filteredTransactions = transactions.filter((item) => ((params.fromLt == null || utils_1.LT_COLLATOR.compare(item.id.lt, params.fromLt) > 0) &&
                        (params.fromUtime == null || item.createdAt > params.fromUtime)));
                    if (filteredTransactions.length == 0) {
                        state.complete = true;
                        break;
                    }
                    const info = {
                        maxLt: filteredTransactions[0].id.lt,
                        minLt: filteredTransactions[filteredTransactions.length - 1].id.lt,
                        batchType: 'old',
                    };
                    this.queue.enqueue(async () => {
                        const isRunning = this.params.onData({
                            address: this.params.address,
                            transactions: filteredTransactions,
                            info,
                        });
                        if (!isRunning) {
                            state.complete = true;
                            this.isRunning = false;
                        }
                    });
                    if (continuation != null) {
                        this.continuation = continuation;
                    }
                    else {
                        state.complete = true;
                        break;
                    }
                }
                catch (e) {
                    console.error(e);
                }
            }
            this.queue.enqueue(async () => this.params.onEnd(state.complete));
            this.isRunning = false;
            this.continuation = undefined;
        })();
    }
    async stop() {
        this.isRunning = false;
        this.queue.clear();
        if (this.promise != null) {
            await this.promise;
        }
        else {
            this.params.onEnd(false);
        }
    }
}
class TraceTransactionsScanner {
    constructor(subscriber, params) {
        this.subscriber = subscriber;
        this.params = params;
        this.queue = new PromiseQueue();
        this.isRunning = false;
        this.streams = new Map();
        this.pendingTransactions = new Map();
    }
    start() {
        if (this.isRunning || this.promise != null) {
            return;
        }
        const subscriber = this.subscriber;
        this.isRunning = true;
        this.promise = (async () => {
            const state = {
                complete: false,
            };
            const fromLt = this.params.origin.id.lt;
            const startDstStreams = (transaction) => {
                for (const message of transaction.outMessages) {
                    if (message.dst == null) {
                        continue;
                    }
                    const address = message.dst.toString();
                    if (this.streams.has(address)) {
                        continue;
                    }
                    const stream = subscriber.oldTransactions(message.dst, { fromLt })
                        .merge(subscriber.transactions(message.dst))
                        .flatMap(({ address, transactions }) => transactions.map(transaction => {
                        transaction.account = address;
                        return transaction;
                    }));
                    this.streams.set(address, stream);
                    stream.on((transaction) => {
                        const messageHash = transaction.inMessage.hash;
                        const pendingTransaction = this.pendingTransactions.get(messageHash);
                        if (pendingTransaction == null) {
                            this.pendingTransactions.set(messageHash, {
                                promise: Promise.resolve(transaction),
                                resolve: () => {
                                },
                                reject: () => {
                                },
                            });
                        }
                        else {
                            pendingTransaction.resolve(transaction);
                        }
                    });
                }
            };
            const transactionsQueue = [this.params.origin];
            try {
                outer: while (this.isRunning) {
                    const transaction = transactionsQueue.shift();
                    if (transaction == null) {
                        state.complete = true;
                        break;
                    }
                    startDstStreams(transaction);
                    for (const message of transaction.outMessages) {
                        if (message.dst == null) {
                            continue;
                        }
                        const pendingTransaction = this.pendingTransactions.get(message.hash);
                        let transactionPromise;
                        if (pendingTransaction == null) {
                            let resolve;
                            let reject;
                            const promise = new Promise((promiseResolve, promiseReject) => {
                                resolve = (tx) => promiseResolve(tx);
                                reject = () => promiseReject();
                            });
                            this.pendingTransactions.set(message.hash, {
                                promise,
                                resolve: resolve,
                                reject: reject,
                            });
                            transactionPromise = promise;
                        }
                        else {
                            transactionPromise = pendingTransaction.promise;
                        }
                        const childTransaction = await transactionPromise;
                        if (!this.isRunning || state.complete) {
                            break outer;
                        }
                        this.queue.enqueue(async () => {
                            const isRunning = this.params.onData(childTransaction);
                            if (!isRunning) {
                                state.complete = true;
                                this.isRunning = false;
                                this.rejectPendingTransactions();
                            }
                        });
                        transactionsQueue.push(childTransaction);
                    }
                }
            }
            catch (e) {
                /* do nothing */
            }
            finally {
                this.queue.enqueue(async () => this.params.onEnd(state.complete));
                this.isRunning = false;
                for (const stream of this.streams.values()) {
                    stream.stopProducer();
                }
            }
        })();
    }
    async stop() {
        this.isRunning = false;
        this.queue.clear();
        this.rejectPendingTransactions();
        if (this.promise != null) {
            await this.promise;
        }
        else {
            this.params.onEnd(false);
        }
    }
    rejectPendingTransactions() {
        for (const pendingTransaction of this.pendingTransactions.values()) {
            pendingTransaction.reject();
        }
    }
}
class PromiseQueue {
    constructor() {
        this.queue = [];
        this.workingOnPromise = false;
    }
    enqueue(promise) {
        this.queue.push(promise);
        this._dequeue().catch(() => {
        });
    }
    clear() {
        this.queue.length = 0;
    }
    async _dequeue() {
        if (this.workingOnPromise) {
            return;
        }
        const item = this.queue.shift();
        if (!item) {
            return;
        }
        this.workingOnPromise = true;
        item()
            .then(() => {
            this.workingOnPromise = false;
            this._dequeue();
        })
            .catch(() => {
            this.workingOnPromise = false;
            this._dequeue();
        });
    }
}
