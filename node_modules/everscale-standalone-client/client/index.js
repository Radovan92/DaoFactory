"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EverscaleStandaloneClient = exports.SUPPORTED_PERMISSIONS = exports.VERSION = exports.DEFAULT_CLIENT_PROPERTIES = exports.Clock = exports.SimpleKeystore = exports.SimpleAccountsStorage = exports.checkConnection = exports.ConnectionError = exports.NETWORK_PRESETS = void 0;
const fast_safe_stringify_1 = __importDefault(require("fast-safe-stringify"));
const core_1 = __importDefault(require("../core"));
const utils_1 = require("./utils");
const ConnectionController_1 = require("./ConnectionController");
const SubscriptionController_1 = require("./SubscriptionController");
var ConnectionController_2 = require("./ConnectionController");
Object.defineProperty(exports, "NETWORK_PRESETS", { enumerable: true, get: function () { return ConnectionController_2.NETWORK_PRESETS; } });
var ConnectionController_3 = require("./ConnectionController");
Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function () { return ConnectionController_3.ConnectionError; } });
Object.defineProperty(exports, "checkConnection", { enumerable: true, get: function () { return ConnectionController_3.checkConnection; } });
var accountsStorage_1 = require("./accountsStorage");
Object.defineProperty(exports, "SimpleAccountsStorage", { enumerable: true, get: function () { return accountsStorage_1.SimpleAccountsStorage; } });
var keystore_1 = require("./keystore");
Object.defineProperty(exports, "SimpleKeystore", { enumerable: true, get: function () { return keystore_1.SimpleKeystore; } });
var clock_1 = require("./clock");
Object.defineProperty(exports, "Clock", { enumerable: true, get: function () { return clock_1.Clock; } });
const { ensureNekotonLoaded, nekoton } = core_1.default;
function validateMessageProperties(message) {
    const m = message || {};
    return {
        retryCount: m.retryCount != null ? Math.max(1, ~~m.retryCount) : 5,
        timeout: m.timeout != null ? Math.max(1, ~~m.timeout) : 60,
        timeoutGrowFactor: m.timeoutGrowFactor || 1.2,
    };
}
/**
 * @category Client
 */
exports.DEFAULT_CLIENT_PROPERTIES = {
    connection: ConnectionController_1.DEFAULT_NETWORK_GROUP,
};
/**
 * @category Client
 */
exports.VERSION = '0.2.25';
/**
 * @category Client
 */
exports.SUPPORTED_PERMISSIONS = ['basic'];
/**
 * @category Client
 */
class EverscaleStandaloneClient extends utils_1.SafeEventEmitter {
    constructor(ctx) {
        super();
        this._handlers = {
            requestPermissions,
            // changeAccount, // not supported
            disconnect,
            subscribe,
            unsubscribe,
            unsubscribeAll,
            getProviderState,
            getFullContractState,
            getAccountsByCodeHash,
            getTransactions,
            getTransaction,
            runLocal,
            getExpectedAddress,
            getBocHash,
            packIntoCell,
            unpackFromCell,
            extractPublicKey,
            codeToTvc,
            mergeTvc,
            splitTvc,
            setCodeSalt,
            getCodeSalt,
            encodeInternalInput,
            decodeInput,
            decodeOutput,
            decodeEvent,
            decodeTransaction,
            decodeTransactionEvents,
            verifySignature,
            sendUnsignedExternalMessage,
            // addAsset, // not supported
            signData,
            signDataRaw,
            // encryptData, // not supported
            // decryptData, // not supported
            // estimateFees, // not supported
            sendMessage,
            sendMessageDelayed,
            sendExternalMessage,
            sendExternalMessageDelayed,
        };
        this._context = ctx;
    }
    static async create(params) {
        await ensureNekotonLoaded(params.initInput);
        // NOTE: capture client inside notify using wrapper object
        const notificationContext = {};
        const notify = (method, params) => {
            var _a;
            (_a = notificationContext.client) === null || _a === void 0 ? void 0 : _a.emit(method, params);
        };
        const clock = new core_1.default.nekoton.ClockWithOffset();
        if (params.clock != null) {
            params.clock['impls'].push(clock);
            clock.updateOffset(params.clock.offset);
        }
        try {
            const connectionController = await (0, ConnectionController_1.createConnectionController)(clock, params.connection);
            const subscriptionController = new SubscriptionController_1.SubscriptionController(connectionController, notify);
            const client = new EverscaleStandaloneClient({
                permissions: {},
                connectionController,
                subscriptionController,
                properties: {
                    message: validateMessageProperties(params.message),
                },
                keystore: params.keystore,
                accountsStorage: params.accountsStorage,
                clock,
                notify,
            });
            // NOTE: WeakRef is not working here, so hope it will be garbage collected
            notificationContext.client = client;
            return client;
        }
        catch (e) {
            if (params.clock != null) {
                params.clock['impls'].pop();
            }
            clock.free();
            throw e;
        }
    }
    request(req) {
        const handler = this._handlers[req.method];
        if (handler == null) {
            throw invalidRequest(req, `Method '${req.method}' is not supported by standalone provider`);
        }
        return handler(this._context, req);
    }
    addListener(eventName, listener) {
        return super.addListener(eventName, listener);
    }
    removeListener(eventName, listener) {
        return super.removeListener(eventName, listener);
    }
    on(eventName, listener) {
        return super.on(eventName, listener);
    }
    once(eventName, listener) {
        return super.once(eventName, listener);
    }
    prependListener(eventName, listener) {
        return super.prependListener(eventName, listener);
    }
    prependOnceListener(eventName, listener) {
        return super.prependOnceListener(eventName, listener);
    }
    computeWalletAddress(workchain, walletType, publicKey) {
        return nekoton.computeWalletAddress(workchain, walletType, publicKey);
    }
    async sendTransfer(walletType, publicKey, recipient, gifts) {
        var _a;
        let repackedRecipient;
        try {
            repackedRecipient = nekoton.repackAddress(recipient);
        }
        catch (e) {
            throw new Error(e.toString());
        }
        const signer = await ((_a = this._context.keystore) === null || _a === void 0 ? void 0 : _a.getSigner(publicKey));
        if (signer == null) {
            throw new Error('Signer not found for public key');
        }
        const accountState = await this._context.connectionController.use(async ({ data: { transport } }) => { var _a; return (_a = (await transport.getFullContractState(repackedRecipient))) === null || _a === void 0 ? void 0 : _a.boc; });
        if (accountState == null) {
            throw new Error('Wallet does not exists');
        }
        let unsignedMessage;
        try {
            unsignedMessage = nekoton.walletPrepareTransfer(this._context.clock, accountState, walletType, publicKey, gifts, 60);
        }
        catch (e) {
            throw new Error(e.toString());
        }
        if (unsignedMessage === undefined) {
            throw new Error('Failed to prepare message');
        }
        let signedMessage;
        try {
            const signature = await signer.sign(unsignedMessage.hash);
            signedMessage = unsignedMessage.sign(signature);
        }
        catch (e) {
            throw new Error(e.toString());
        }
        finally {
            unsignedMessage.free();
        }
        const transaction = await this._context.subscriptionController.sendMessage(repackedRecipient, signedMessage);
        if (transaction == null) {
            throw new Error('Message expired');
        }
        return transaction;
    }
}
exports.EverscaleStandaloneClient = EverscaleStandaloneClient;
const requestPermissions = async (ctx, req) => {
    requireParams(req);
    const { permissions } = req.params;
    requireArray(req, req.params, 'permissions');
    const newPermissions = { ...ctx.permissions };
    for (const permission of permissions) {
        if (permission === 'basic' || permission === 'tonClient') {
            newPermissions.basic = true;
        }
        else {
            throw invalidRequest(req, `Permission '${permission}' is not supported by standalone provider`);
        }
    }
    ctx.permissions = newPermissions;
    // NOTE: be sure to return object copy to prevent adding new permissions
    ctx.notify('permissionsChanged', {
        permissions: { ...newPermissions },
    });
    return { ...newPermissions };
};
const disconnect = async (ctx, _req) => {
    ctx.permissions = {};
    await ctx.subscriptionController.unsubscribeFromAllContracts();
    ctx.notify('permissionsChanged', { permissions: {} });
    return undefined;
};
const subscribe = async (ctx, req) => {
    requireParams(req);
    const { address, subscriptions } = req.params;
    requireString(req, req.params, 'address');
    requireOptionalObject(req, req.params, 'subscriptions');
    let repackedAddress;
    try {
        repackedAddress = nekoton.repackAddress(address);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    try {
        return await ctx.subscriptionController.subscribeToContract(repackedAddress, subscriptions);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const unsubscribe = async (ctx, req) => {
    requireParams(req);
    const { address } = req.params;
    requireString(req, req.params, 'address');
    let repackedAddress;
    try {
        repackedAddress = nekoton.repackAddress(address);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    await ctx.subscriptionController.unsubscribeFromContract(repackedAddress);
    return undefined;
};
const unsubscribeAll = async (ctx, _req) => {
    await ctx.subscriptionController.unsubscribeFromAllContracts();
    return undefined;
};
const getProviderState = async (ctx, req) => {
    const transport = ctx.connectionController.initializedTransport;
    if (transport == null) {
        throw invalidRequest(req, 'Connection controller was not initialized');
    }
    const version = exports.VERSION;
    return {
        version,
        numericVersion: (0, utils_1.convertVersionToInt32)(version),
        networkId: transport.id,
        selectedConnection: transport.group,
        supportedPermissions: [...exports.SUPPORTED_PERMISSIONS],
        permissions: { ...ctx.permissions },
        subscriptions: ctx.subscriptionController.subscriptionStates,
    };
};
const getFullContractState = async (ctx, req) => {
    requireParams(req);
    const { address } = req.params;
    requireString(req, req.params, 'address');
    const { connectionController } = ctx;
    try {
        return connectionController.use(async ({ data: { transport } }) => ({
            state: await transport.getFullContractState(address),
        }));
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const getAccountsByCodeHash = async (ctx, req) => {
    requireParams(req);
    const { codeHash, limit, continuation } = req.params;
    requireString(req, req.params, 'codeHash');
    requireOptionalNumber(req, req.params, 'limit');
    requireOptionalString(req, req.params, 'continuation');
    const { connectionController } = ctx;
    try {
        return connectionController.use(({ data: { transport } }) => transport.getAccountsByCodeHash(codeHash, limit || 50, continuation));
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const getTransactions = async (ctx, req) => {
    requireParams(req);
    const { address, continuation, limit } = req.params;
    requireString(req, req.params, 'address');
    requireOptional(req, req.params, 'continuation', requireTransactionId);
    requireOptionalNumber(req, req.params, 'limit');
    const { connectionController } = ctx;
    try {
        return connectionController.use(({ data: { transport } }) => transport.getTransactions(address, continuation === null || continuation === void 0 ? void 0 : continuation.lt, limit || 50));
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const getTransaction = async (ctx, req) => {
    requireParams(req);
    const { hash } = req.params;
    requireString(req, req.params, 'hash');
    const { connectionController } = ctx;
    try {
        return {
            transaction: await connectionController.use(({ data: { transport } }) => transport.getTransaction(hash)),
        };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const runLocal = async (ctx, req) => {
    requireParams(req);
    const { address, cachedState, responsible, functionCall } = req.params;
    requireString(req, req.params, 'address');
    requireOptional(req, req.params, 'cachedState', requireContractState);
    requireOptionalBoolean(req, req.params, 'responsible');
    requireFunctionCall(req, req.params, 'functionCall');
    const { clock, connectionController } = ctx;
    let contractState = cachedState;
    if (contractState == null) {
        contractState = await connectionController.use(async ({ data: { transport } }) => transport.getFullContractState(address));
    }
    if (contractState == null) {
        throw invalidRequest(req, 'Account not found');
    }
    if (!contractState.isDeployed || contractState.lastTransactionId == null) {
        throw invalidRequest(req, 'Account is not deployed');
    }
    try {
        const { output, code } = nekoton.runLocal(clock, contractState.boc, functionCall.abi, functionCall.method, functionCall.params, responsible || false);
        return { output, code };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const getExpectedAddress = async (_ctx, req) => {
    requireParams(req);
    const { tvc, abi, workchain, publicKey, initParams } = req.params;
    requireString(req, req.params, 'tvc');
    requireString(req, req.params, 'abi');
    requireOptionalNumber(req, req.params, 'workchain');
    requireOptionalString(req, req.params, 'publicKey');
    try {
        return nekoton.getExpectedAddress(tvc, abi, workchain || 0, publicKey, initParams);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const getBocHash = async (_ctx, req) => {
    requireParams(req);
    const { boc } = req.params;
    requireString(req, req.params, 'boc');
    try {
        return { hash: nekoton.getBocHash(boc) };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const packIntoCell = async (_ctx, req) => {
    requireParams(req);
    const { structure, data } = req.params;
    requireArray(req, req.params, 'structure');
    try {
        return { boc: nekoton.packIntoCell(structure, data) };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const unpackFromCell = async (_ctx, req) => {
    requireParams(req);
    const { structure, boc, allowPartial } = req.params;
    requireArray(req, req.params, 'structure');
    requireString(req, req.params, 'boc');
    requireBoolean(req, req.params, 'allowPartial');
    try {
        return { data: nekoton.unpackFromCell(structure, boc, allowPartial) };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const extractPublicKey = async (_ctx, req) => {
    requireParams(req);
    const { boc } = req.params;
    requireString(req, req.params, 'boc');
    try {
        return { publicKey: nekoton.extractPublicKey(boc) };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const codeToTvc = async (_ctx, req) => {
    requireParams(req);
    const { code } = req.params;
    requireString(req, req.params, 'code');
    try {
        return { tvc: nekoton.codeToTvc(code) };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const mergeTvc = async (_ctx, req) => {
    requireParams(req);
    const { code, data } = req.params;
    requireString(req, req.params, 'code');
    requireString(req, req.params, 'data');
    try {
        return { tvc: nekoton.mergeTvc(code, data) };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const splitTvc = async (_ctx, req) => {
    requireParams(req);
    const { tvc } = req.params;
    requireString(req, req.params, 'tvc');
    try {
        return nekoton.splitTvc(tvc);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const setCodeSalt = async (_ctx, req) => {
    requireParams(req);
    const { code, salt } = req.params;
    requireString(req, req.params, 'code');
    requireString(req, req.params, 'salt');
    try {
        return { code: nekoton.setCodeSalt(code, salt) };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const getCodeSalt = async (_ctx, req) => {
    requireParams(req);
    const { code } = req.params;
    requireString(req, req.params, 'code');
    try {
        return { salt: nekoton.getCodeSalt(code) };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const encodeInternalInput = async (_ctx, req) => {
    requireParams(req);
    requireFunctionCall(req, req, 'params');
    const { abi, method, params } = req.params;
    try {
        return { boc: nekoton.encodeInternalInput(abi, method, params) };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const decodeInput = async (_ctx, req) => {
    requireParams(req);
    const { body, abi, method, internal } = req.params;
    requireString(req, req.params, 'body');
    requireString(req, req.params, 'abi');
    requireMethodOrArray(req, req.params, 'method');
    requireBoolean(req, req.params, 'internal');
    try {
        return nekoton.decodeInput(body, abi, method, internal) || null;
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const decodeOutput = async (_ctx, req) => {
    requireParams(req);
    const { body, abi, method } = req.params;
    requireString(req, req.params, 'body');
    requireString(req, req.params, 'abi');
    requireMethodOrArray(req, req.params, 'method');
    try {
        return nekoton.decodeOutput(body, abi, method) || null;
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const decodeEvent = async (_ctx, req) => {
    requireParams(req);
    const { body, abi, event } = req.params;
    requireString(req, req.params, 'body');
    requireString(req, req.params, 'abi');
    requireMethodOrArray(req, req.params, 'event');
    try {
        return nekoton.decodeEvent(body, abi, event) || null;
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const decodeTransaction = async (_ctx, req) => {
    requireParams(req);
    const { transaction, abi, method } = req.params;
    requireString(req, req.params, 'abi');
    requireMethodOrArray(req, req.params, 'method');
    try {
        return nekoton.decodeTransaction(transaction, abi, method) || null;
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const decodeTransactionEvents = async (_ctx, req) => {
    requireParams(req);
    const { transaction, abi } = req.params;
    requireString(req, req.params, 'abi');
    try {
        return { events: nekoton.decodeTransactionEvents(transaction, abi) };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const verifySignature = async (_ctx, req) => {
    requireParams(req);
    const { publicKey, dataHash, signature } = req.params;
    requireString(req, req.params, 'publicKey');
    requireString(req, req.params, 'dataHash');
    requireString(req, req.params, 'signature');
    try {
        return { isValid: nekoton.verifySignature(publicKey, dataHash, signature) };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const sendUnsignedExternalMessage = async (ctx, req) => {
    requireParams(req);
    const { recipient, stateInit, payload, local } = req.params;
    requireString(req, req.params, 'recipient');
    requireOptionalString(req, req.params, 'stateInit');
    requireFunctionCall(req, req.params, 'payload');
    requireOptionalBoolean(req, req.params, 'local');
    let repackedRecipient;
    try {
        repackedRecipient = nekoton.repackAddress(recipient);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    const { clock, subscriptionController, properties } = ctx;
    const makeSignedMessage = (timeout) => {
        try {
            return nekoton.createExternalMessageWithoutSignature(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, timeout);
        }
        catch (e) {
            throw invalidRequest(req, e.toString());
        }
    };
    const handleTransaction = (transaction) => {
        let output;
        try {
            const decoded = nekoton.decodeTransaction(transaction, payload.abi, payload.method);
            output = decoded === null || decoded === void 0 ? void 0 : decoded.output;
        }
        catch (_) { /* do nothing */
        }
        return { transaction, output };
    };
    // Force local execution
    if (local === true) {
        const signedMessage = makeSignedMessage(60);
        const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage);
        return handleTransaction(transaction);
    }
    // Send and wait with several retries
    let timeout = properties.message.timeout;
    for (let retry = 0; retry < properties.message.retryCount; ++retry) {
        const signedMessage = makeSignedMessage(timeout);
        const transaction = await subscriptionController.sendMessage(repackedRecipient, signedMessage);
        if (transaction == null) {
            timeout *= properties.message.timeoutGrowFactor;
            continue;
        }
        return handleTransaction(transaction);
    }
    // Execute locally
    const errorMessage = 'Message expired';
    const signedMessage = makeSignedMessage(60);
    const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage)
        .catch((e) => {
        throw invalidRequest(req, `${errorMessage}. ${e.toString()}`);
    });
    const additionalText = transaction.exitCode != null ? `. Possible exit code: ${transaction.exitCode}` : '';
    throw invalidRequest(req, `${errorMessage}${additionalText}`);
};
const signData = async (ctx, req) => {
    requireKeystore(req, ctx);
    requireParams(req);
    const { publicKey, data } = req.params;
    requireString(req, req.params, 'publicKey');
    requireString(req, req.params, 'data');
    const { keystore } = ctx;
    const signer = await keystore.getSigner(publicKey);
    if (signer == null) {
        throw invalidRequest(req, 'Signer not found for public key');
    }
    try {
        const dataHash = nekoton.getDataHash(data);
        return {
            dataHash,
            ...(await signer.sign(dataHash).then(nekoton.extendSignature)),
        };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const signDataRaw = async (ctx, req) => {
    requireKeystore(req, ctx);
    requireParams(req);
    const { publicKey, data } = req.params;
    requireString(req, req.params, 'publicKey');
    requireString(req, req.params, 'data');
    const { keystore } = ctx;
    const signer = await keystore.getSigner(publicKey);
    if (signer == null) {
        throw invalidRequest(req, 'Signer not found for public key');
    }
    try {
        return await signer.sign(data).then(nekoton.extendSignature);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const sendMessage = async (ctx, req) => {
    requireKeystore(req, ctx);
    requireAccountsStorage(req, ctx);
    requireParams(req);
    const { sender, recipient, amount, bounce, payload } = req.params;
    requireString(req, req.params, 'sender');
    requireString(req, req.params, 'recipient');
    requireString(req, req.params, 'amount');
    requireBoolean(req, req.params, 'bounce');
    requireOptional(req, req.params, 'payload', requireFunctionCall);
    const { clock, subscriptionController, keystore, accountsStorage } = ctx;
    let repackedSender;
    let repackedRecipient;
    try {
        repackedSender = nekoton.repackAddress(sender);
        repackedRecipient = nekoton.repackAddress(recipient);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    let signedMessage;
    try {
        const account = await accountsStorage.getAccount(repackedSender);
        if (account == null) {
            throw new Error('Sender not found');
        }
        signedMessage = await account.prepareMessage({
            recipient: repackedRecipient,
            amount,
            bounce,
            payload,
            stateInit: undefined,
        }, {
            clock,
            keystore,
        });
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    const transaction = await subscriptionController.sendMessage(repackedSender, signedMessage);
    if (transaction == null) {
        throw invalidRequest(req, 'Message expired');
    }
    return { transaction };
};
const sendMessageDelayed = async (ctx, req) => {
    requireKeystore(req, ctx);
    requireAccountsStorage(req, ctx);
    requireParams(req);
    const { sender, recipient, amount, bounce, payload } = req.params;
    requireString(req, req.params, 'sender');
    requireString(req, req.params, 'recipient');
    requireString(req, req.params, 'amount');
    requireBoolean(req, req.params, 'bounce');
    requireOptional(req, req.params, 'payload', requireFunctionCall);
    const { clock, subscriptionController, keystore, accountsStorage, notify } = ctx;
    let repackedSender;
    let repackedRecipient;
    try {
        repackedSender = nekoton.repackAddress(sender);
        repackedRecipient = nekoton.repackAddress(recipient);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    let signedMessage;
    try {
        const account = await accountsStorage.getAccount(repackedSender);
        if (account == null) {
            throw new Error('Sender not found');
        }
        signedMessage = await account.prepareMessage({
            recipient: repackedRecipient,
            amount,
            bounce,
            payload,
            stateInit: undefined,
        }, {
            clock,
            keystore,
        });
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    subscriptionController.sendMessage(repackedSender, signedMessage)
        .then(transaction => {
        notify('messageStatusUpdated', {
            address: repackedSender,
            hash: signedMessage.hash,
            transaction,
        });
    })
        .catch(console.error);
    return {
        message: {
            account: repackedSender,
            hash: signedMessage.hash,
            expireAt: signedMessage.expireAt,
        },
    };
};
const sendExternalMessage = async (ctx, req) => {
    requireKeystore(req, ctx);
    requireParams(req);
    const { publicKey, recipient, stateInit, payload, local } = req.params;
    requireString(req, req.params, 'publicKey');
    requireString(req, req.params, 'recipient');
    requireOptionalString(req, req.params, 'stateInit');
    requireFunctionCall(req, req.params, 'payload');
    requireOptionalBoolean(req, req.params, 'local');
    let repackedRecipient;
    try {
        repackedRecipient = nekoton.repackAddress(recipient);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    const { clock, subscriptionController, keystore, properties } = ctx;
    const signer = await keystore.getSigner(publicKey);
    if (signer == null) {
        throw invalidRequest(req, 'Signer not found for public key');
    }
    const makeSignedMessage = async (timeout) => {
        let unsignedMessage;
        try {
            unsignedMessage = nekoton.createExternalMessage(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, publicKey, timeout);
        }
        catch (e) {
            throw invalidRequest(req, e.toString());
        }
        try {
            const signature = await signer.sign(unsignedMessage.hash);
            return unsignedMessage.sign(signature);
        }
        catch (e) {
            throw invalidRequest(req, e.toString());
        }
        finally {
            unsignedMessage.free();
        }
    };
    const handleTransaction = (transaction) => {
        let output;
        try {
            const decoded = nekoton.decodeTransaction(transaction, payload.abi, payload.method);
            output = decoded === null || decoded === void 0 ? void 0 : decoded.output;
        }
        catch (_) { /* do nothing */
        }
        return { transaction, output };
    };
    // Force local execution
    if (local === true) {
        const signedMessage = await makeSignedMessage(60);
        const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage);
        return handleTransaction(transaction);
    }
    // Send and wait with several retries
    let timeout = properties.message.timeout;
    for (let retry = 0; retry < properties.message.retryCount; ++retry) {
        const signedMessage = await makeSignedMessage(timeout);
        const transaction = await subscriptionController.sendMessage(repackedRecipient, signedMessage);
        if (transaction == null) {
            timeout *= properties.message.timeoutGrowFactor;
            continue;
        }
        return handleTransaction(transaction);
    }
    // Execute locally
    const errorMessage = 'Message expired';
    const signedMessage = await makeSignedMessage(60);
    const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage)
        .catch((e) => {
        throw invalidRequest(req, `${errorMessage}. ${e.toString()}`);
    });
    const additionalText = transaction.exitCode != null ? `. Possible exit code: ${transaction.exitCode}` : '';
    throw invalidRequest(req, `${errorMessage}${additionalText}`);
};
const sendExternalMessageDelayed = async (ctx, req) => {
    requireKeystore(req, ctx);
    requireParams(req);
    const { publicKey, recipient, stateInit, payload } = req.params;
    requireString(req, req.params, 'publicKey');
    requireString(req, req.params, 'recipient');
    requireOptionalString(req, req.params, 'stateInit');
    requireFunctionCall(req, req.params, 'payload');
    let repackedRecipient;
    try {
        repackedRecipient = nekoton.repackAddress(recipient);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    const { clock, subscriptionController, keystore, properties, notify } = ctx;
    const signer = await keystore.getSigner(publicKey);
    if (signer == null) {
        throw invalidRequest(req, 'Signer not found for public key');
    }
    let unsignedMessage;
    try {
        unsignedMessage = nekoton.createExternalMessage(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, publicKey, properties.message.timeout);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    let signedMessage;
    try {
        const signature = await signer.sign(unsignedMessage.hash);
        signedMessage = unsignedMessage.sign(signature);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    finally {
        unsignedMessage.free();
    }
    subscriptionController.sendMessage(repackedRecipient, signedMessage)
        .then(transaction => {
        notify('messageStatusUpdated', {
            address: repackedRecipient,
            hash: signedMessage.hash,
            transaction,
        });
    })
        .catch(console.error);
    return {
        message: {
            account: repackedRecipient,
            hash: signedMessage.hash,
            expireAt: signedMessage.expireAt,
        },
    };
};
function requireKeystore(req, context) {
    if (context.keystore == null) {
        throw invalidRequest(req, 'Keystore not found');
    }
}
function requireAccountsStorage(req, context) {
    if (context.accountsStorage == null) {
        throw invalidRequest(req, 'AccountsStorage not found');
    }
}
function requireParams(req) {
    if (req.params == null || typeof req.params !== 'object') {
        throw invalidRequest(req, 'required params object');
    }
}
function requireObject(req, object, key) {
    const property = object[key];
    if (typeof property !== 'object') {
        throw invalidRequest(req, `'${String(key)}' must be an object`);
    }
}
function requireOptionalObject(req, object, key) {
    const property = object[key];
    if (property != null && typeof property !== 'object') {
        throw invalidRequest(req, `'${String(key)}' must be an object if specified`);
    }
}
function requireBoolean(req, object, key) {
    const property = object[key];
    if (typeof property !== 'boolean') {
        throw invalidRequest(req, `'${String(key)}' must be a boolean`);
    }
}
function requireOptionalBoolean(req, object, key) {
    const property = object[key];
    if (property != null && typeof property !== 'boolean') {
        throw invalidRequest(req, `'${String(key)}' must be a boolean if specified`);
    }
}
function requireString(req, object, key) {
    const property = object[key];
    if (typeof property !== 'string' || property.length === 0) {
        throw invalidRequest(req, `'${String(key)}' must be non-empty string`);
    }
}
function requireOptionalString(req, object, key) {
    const property = object[key];
    if (property != null && (typeof property !== 'string' || property.length === 0)) {
        throw invalidRequest(req, `'${String(key)}' must be a non-empty string if provided`);
    }
}
function requireOptionalNumber(req, object, key) {
    const property = object[key];
    if (property != null && typeof property !== 'number') {
        throw invalidRequest(req, `'${String(key)}' must be a number if provider`);
    }
}
function requireArray(req, object, key) {
    const property = object[key];
    if (!Array.isArray(property)) {
        throw invalidRequest(req, `'${String(key)}' must be an array`);
    }
}
function requireOptional(req, object, key, predicate) {
    const property = object[key];
    if (property != null) {
        predicate(req, object, key);
    }
}
function requireTransactionId(req, object, key) {
    requireObject(req, object, key);
    const property = object[key];
    requireString(req, property, 'lt');
    requireString(req, property, 'hash');
}
function requireLastTransactionId(req, object, key) {
    requireObject(req, object, key);
    const property = object[key];
    requireBoolean(req, property, 'isExact');
    requireString(req, property, 'lt');
    requireOptionalString(req, property, 'hash');
}
function requireContractState(req, object, key) {
    requireObject(req, object, key);
    const property = object[key];
    requireString(req, property, 'balance');
    requireOptional(req, property, 'lastTransactionId', requireLastTransactionId);
    requireBoolean(req, property, 'isDeployed');
}
function requireFunctionCall(req, object, key) {
    requireObject(req, object, key);
    const property = object[key];
    requireString(req, property, 'abi');
    requireString(req, property, 'method');
    requireObject(req, property, 'params');
}
function requireMethodOrArray(req, object, key) {
    const property = object[key];
    if (property != null && typeof property !== 'string' && !Array.isArray(property)) {
        throw invalidRequest(req, `'${String(key)}' must be a method name or an array of possible names`);
    }
}
const invalidRequest = (req, message, data) => new NekotonRpcError(2, `${req.method}: ${message}`, data);
class NekotonRpcError extends Error {
    constructor(code, message, data) {
        if (!Number.isInteger(code)) {
            throw new Error('"code" must be an integer');
        }
        if (!message || typeof message !== 'string') {
            throw new Error('"message" must be a nonempty string');
        }
        super(message);
        this.code = code;
        this.data = data;
    }
    serialize() {
        const serialized = {
            code: this.code,
            message: this.message,
        };
        if (this.data !== undefined) {
            serialized.data = this.data;
        }
        if (this.stack) {
            serialized.stack = this.stack;
        }
        return serialized;
    }
    toString() {
        return (0, fast_safe_stringify_1.default)(this.serialize(), stringifyReplacer, 2);
    }
}
const stringifyReplacer = (_, value) => {
    if (value === '[Circular]') {
        return undefined;
    }
    return value;
};
