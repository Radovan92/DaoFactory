import { Address, UniqueArray } from './utils';
import { AbiParam, FullContractState, Transaction, AbiFunctionName, AbiEventName, AbiFunctionInputs, DecodedAbiFunctionOutputs, DecodedAbiFunctionInputs, AbiFunctionInputsWithDefault, DecodedAbiEventData, TransactionId } from './models';
import { Stream, Subscriber } from './stream';
import { ProviderRpcClient } from './index';
/**
 * @category Contract
 */
export declare class Contract<Abi> {
    private readonly _provider;
    private readonly _abi;
    private readonly _functions;
    private readonly _events;
    private readonly _address;
    private readonly _methods;
    constructor(provider: ProviderRpcClient, abi: Abi, address: Address);
    get methods(): ContractMethods<Abi>;
    get address(): Address;
    get abi(): string;
    /**
     * Creates new contract transactions stream
     *
     * @param subscriber
     */
    transactions(subscriber: Subscriber): Stream<unknown, Transaction>;
    /**
     * Creates new contract events stream
     *
     * @param subscriber
     */
    events(subscriber: Subscriber): Stream<unknown, DecodedEventWithTransaction<Abi, AbiEventName<Abi>>>;
    waitForEvent(args?: WaitForEventParams<Abi>): Promise<DecodedEvent<Abi, AbiEventName<Abi>> | undefined>;
    getPastEvents(args: GetPastEventParams<Abi>): Promise<EventsBatch<Abi>>;
    decodeTransaction(args: DecodeTransactionParams<Abi>): Promise<DecodedTransaction<Abi, AbiFunctionName<Abi>> | undefined>;
    decodeTransactionEvents(args: DecodeTransactionEventsParams): Promise<DecodedEvent<Abi, AbiEventName<Abi>>[]>;
    decodeInputMessage(args: DecodeInputParams<Abi>): Promise<DecodedInput<Abi, AbiFunctionName<Abi>> | undefined>;
    decodeOutputMessage(args: DecodeOutputParams<Abi>): Promise<DecodedOutput<Abi, AbiFunctionName<Abi>> | undefined>;
    decodeEvent(args: DecodeEventParams<Abi>): Promise<DecodedEvent<Abi, AbiEventName<Abi>> | undefined>;
}
/**
 * @category Contract
 */
export declare class TvmException extends Error {
    readonly code: number;
    constructor(code: number);
}
/**
 * @category Contract
 */
export declare type DelayedMessageExecution = {
    /**
     * External message hash
     */
    messageHash: string;
    /**
     * Message expiration timestamp
     */
    expireAt: number;
    /**
     * Transaction promise (it will be rejected if the message has expired)
     */
    transaction: Promise<Transaction>;
};
/**
 * @category Contract
 */
export declare type ContractMethods<C> = {
    [K in AbiFunctionName<C>]: (params: AbiFunctionInputsWithDefault<C, K>) => ContractMethod<AbiFunctionInputs<C, K>, DecodedAbiFunctionOutputs<C, K>>;
};
/**
 * @category Contract
 */
export interface ContractMethod<I, O> {
    /**
     * Target contract address
     */
    readonly address: Address;
    readonly abi: string;
    readonly method: string;
    readonly params: I;
    /**
     * Sends internal message and returns wallet transaction
     *
     * @param args
     */
    send(args: SendInternalParams): Promise<Transaction>;
    /**
     * Sends internal message without waiting for the transaction
     *
     * @param args
     */
    sendDelayed(args: SendInternalParams): Promise<DelayedMessageExecution>;
    /**
     * Sends internal message and waits for the new transaction on target address
     *
     * @param args
     */
    sendWithResult(args: SendInternalParams): Promise<{
        parentTransaction: Transaction;
        childTransaction: Transaction;
        output?: O;
    }>;
    /**
     * Estimates wallet fee for calling this method as an internal message
     *
     * @param args
     */
    estimateFees(args: SendInternalParams): Promise<string>;
    /**
     * Sends external message and returns contract transaction with parsed output
     *
     * @param args
     */
    sendExternal(args: SendExternalParams): Promise<{
        transaction: Transaction;
        output?: O;
    }>;
    /**
     * Sends external message without waiting for the transaction
     *
     * @param args
     */
    sendExternalDelayed(args: SendExternalDelayedParams): Promise<DelayedMessageExecution>;
    /**
     * Runs message locally
     *
     * @param args
     */
    call(args?: CallParams): Promise<O>;
    /**
     * Encodes method call as BOC
     */
    encodeInternal(): Promise<string>;
}
/**
 * @category Contract
 */
export declare type ContractFunction = {
    name: string;
    inputs?: AbiParam[];
    outputs?: AbiParam[];
};
/**
 * @category Contract
 */
export declare type SendInternalParams = {
    from: Address;
    amount: string;
    /**
     * @default true
     */
    bounce?: boolean;
};
/**
 * @category Contract
 */
export declare type SendInternalWithResultParams = SendInternalParams & {
    /**
     * Existing subscriber
     */
    subscriber?: Subscriber;
};
/**
 * @category Contract
 */
export declare type SendExternalParams = {
    publicKey: string;
    stateInit?: string;
    /**
     * Whether to run this message locally. Default: false
     */
    local?: boolean;
    /**
     * Whether to prepare this message without signature. Default: false
     */
    withoutSignature?: boolean;
};
/**
 * @category Contract
 */
export declare type SendExternalDelayedParams = {
    publicKey: string;
    stateInit?: string;
};
/**
 * @category Contract
 */
export declare type CallParams = {
    /**
     * Cached contract state
     */
    cachedState?: FullContractState;
    /**
     * Whether to run the method locally as responsible.
     *
     * This will use internal message with unlimited account balance.
     */
    responsible?: boolean;
};
/**
 * @category Contract
 */
export declare type GetPastEventParams<Abi> = {
    filter?: EventsFilter<Abi, AbiEventName<Abi>>;
    range?: EventsRange;
    limit?: number;
    continuation?: TransactionId;
};
/**
 * @category Contract
 */
export declare type WaitForEventParams<Abi> = {
    filter?: EventsFilter<Abi, AbiEventName<Abi>>;
    range?: EventsRange;
    subscriber?: Subscriber;
};
/**
 * @category Contract
 */
export declare type EventsBatch<Abi> = {
    events: DecodedEventWithTransaction<Abi, AbiEventName<Abi>>[];
    continuation?: TransactionId;
};
/**
 * @category Contract
 */
export declare type EventsFilter<Abi, E extends AbiEventName<Abi> = AbiEventName<Abi>> = (event: DecodedEventWithTransaction<Abi, E>) => (Promise<boolean> | boolean);
/**
 * @category Contract
 */
export declare type DecodedEventWithTransaction<Abi, E extends AbiEventName<Abi>> = DecodedEvent<Abi, E> & {
    transaction: Transaction;
};
/**
 * @category Contract
 */
export declare type EventsRange = {
    fromLt?: string;
    fromUtime?: number;
    toLt?: string;
    toUtime?: number;
};
/**
 * @category Contract
 */
export declare type DecodeTransactionParams<Abi> = {
    transaction: Transaction;
    methods: UniqueArray<AbiFunctionName<Abi>[]>;
};
/**
 * @category Contract
 */
export declare type DecodedTransaction<Abi, T> = T extends AbiFunctionName<Abi> ? {
    method: T;
    input: DecodedAbiFunctionInputs<Abi, T>;
    output: DecodedAbiFunctionOutputs<Abi, T>;
} : never;
/**
 * @category Contract
 */
export declare type DecodeInputParams<Abi> = {
    body: string;
    methods: UniqueArray<AbiFunctionName<Abi>[]>;
    internal: boolean;
};
/**
 * @category Contract
 */
export declare type DecodedInput<Abi, T> = T extends AbiFunctionName<Abi> ? {
    method: T;
    input: DecodedAbiFunctionInputs<Abi, T>;
} : never;
/**
 * @category Contract
 */
export declare type DecodeOutputParams<Abi> = {
    /**
     * Base64 encoded message body BOC
     */
    body: string;
    methods: UniqueArray<AbiFunctionName<Abi>[]>;
};
/**
 * @category Contract
 */
export declare type DecodeEventParams<Abi> = {
    /**
     * Base64 encoded message body BOC
     */
    body: string;
    events: UniqueArray<AbiEventName<Abi>[]>;
};
/**
 * @category Contract
 */
export declare type DecodedOutput<Abi, T> = T extends AbiFunctionName<Abi> ? {
    method: T;
    output: DecodedAbiFunctionOutputs<Abi, T>;
} : never;
/**
 * @category Contract
 */
export declare type DecodeTransactionEventsParams = {
    transaction: Transaction;
};
/**
 * @category Contract
 */
export declare type DecodedEvent<Abi, T> = T extends AbiEventName<Abi> ? {
    event: T;
    data: DecodedAbiEventData<Abi, T>;
} : never;
